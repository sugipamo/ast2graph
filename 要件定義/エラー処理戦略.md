# ast2graph ã‚¨ãƒ©ãƒ¼å‡¦ç†æˆ¦ç•¥è¨­è¨ˆæ›¸

## 1. æ¦‚è¦

ast2graphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®çµ±ä¸€çš„ãªæˆ¦ç•¥ã¨å®Ÿè£…æ–¹é‡ã‚’å®šç¾©ã—ã¾ã™ã€‚

## 2. ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®åŸºæœ¬æ–¹é‡

### 2.1 åŸå‰‡
- **fail-fast**: å›å¾©ä¸å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã¯æ—©æœŸã«å¤±æ•—
- **graceful degradation**: éƒ¨åˆ†çš„å¤±æ•—ã§ã‚‚å¯èƒ½ãªé™ã‚Šå‡¦ç†ç¶™ç¶š
- **æ˜ç¢ºãªã‚¨ãƒ©ãƒ¼æƒ…å ±**: ãƒ‡ãƒãƒƒã‚°å¯èƒ½ãªè©³ç´°æƒ…å ±ã‚’æä¾›
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼**: å¯¾å‡¦æ–¹æ³•ã‚’å«ã‚€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

### 2.2 ã‚¨ãƒ©ãƒ¼åˆ†é¡

| ã‚«ãƒ†ã‚´ãƒª | å‡¦ç†æ–¹é‡ | ä¾‹ |
|---------|---------|---|
| **è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼** | å³åº§ã«å‡¦ç†åœæ­¢ | Neo4jæ¥ç¶šä¸å¯ã€ãƒ¡ãƒ¢ãƒªä¸è¶³ |
| **å›å¾©å¯èƒ½ã‚¨ãƒ©ãƒ¼** | å†è©¦è¡Œå¾Œã€å¤±æ•—ãªã‚‰ç¶™ç¶š | ä¸€æ™‚çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ |
| **è­¦å‘Šãƒ¬ãƒ™ãƒ«** | ãƒ­ã‚°å‡ºåŠ›ã—ã¦å‡¦ç†ç¶™ç¶š | æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã€éæ¨å¥¨æ©Ÿèƒ½ |
| **ç„¡è¦–å¯èƒ½** | ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®ã¿ | ç©ºãƒ•ã‚¡ã‚¤ãƒ«ã€ã‚³ãƒ¡ãƒ³ãƒˆã®ã¿ |

## 3. ã‚¨ãƒ©ãƒ¼éšå±¤è¨­è¨ˆ

### 3.1 ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–ã‚¯ãƒ©ã‚¹

```python
# åŸºåº•ä¾‹å¤–ã‚¯ãƒ©ã‚¹
class AST2GraphError(Exception):
    """ast2graphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åŸºåº•ä¾‹å¤–ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(message)
        self.error_code = error_code
        self.details = details or {}
        self.timestamp = datetime.utcnow()

# ã‚«ãƒ†ã‚´ãƒªåˆ¥ä¾‹å¤–
class ParseError(AST2GraphError):
    """Pythonæ§‹æ–‡è§£æã‚¨ãƒ©ãƒ¼"""
    pass

class GraphBuildError(AST2GraphError):
    """ã‚°ãƒ©ãƒ•æ§‹é€ æ§‹ç¯‰ã‚¨ãƒ©ãƒ¼"""
    pass

class Neo4jConnectionError(AST2GraphError):
    """Neo4jæ¥ç¶šã‚¨ãƒ©ãƒ¼"""
    pass

class ConfigurationError(AST2GraphError):
    """è¨­å®šã‚¨ãƒ©ãƒ¼"""
    pass

class ValidationError(AST2GraphError):
    """ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼"""
    pass
```

### 3.2 ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ä½“ç³»

```python
class ErrorCode:
    # æ§‹æ–‡è§£æã‚¨ãƒ©ãƒ¼ (1xxx)
    SYNTAX_ERROR = "AST_1001"
    ENCODING_ERROR = "AST_1002"
    FILE_NOT_FOUND = "AST_1003"
    
    # ã‚°ãƒ©ãƒ•æ§‹ç¯‰ã‚¨ãƒ©ãƒ¼ (2xxx)
    INVALID_NODE_TYPE = "GRAPH_2001"
    CIRCULAR_DEPENDENCY = "GRAPH_2002"
    
    # Neo4jé–¢é€£ã‚¨ãƒ©ãƒ¼ (3xxx)
    CONNECTION_FAILED = "NEO4J_3001"
    AUTHENTICATION_FAILED = "NEO4J_3002"
    QUERY_FAILED = "NEO4J_3003"
    TRANSACTION_FAILED = "NEO4J_3004"
    
    # è¨­å®šã‚¨ãƒ©ãƒ¼ (4xxx)
    MISSING_CONFIG = "CONFIG_4001"
    INVALID_CONFIG = "CONFIG_4002"
```

## 4. ã‚¨ãƒ©ãƒ¼å‡¦ç†å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

### 4.1 ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```python
class FileProcessor:
    def __init__(self, error_strategy: str = "continue"):
        """
        error_strategy:
        - "continue": ã‚¨ãƒ©ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç¶™ç¶š
        - "fail_fast": æœ€åˆã®ã‚¨ãƒ©ãƒ¼ã§åœæ­¢
        - "collect": å…¨ã‚¨ãƒ©ãƒ¼ã‚’åé›†ã—ã¦ã‹ã‚‰å ±å‘Š
        """
        self.error_strategy = error_strategy
        self.errors = []
    
    def process_files(self, file_paths: List[str]) -> ProcessResult:
        results = []
        
        for file_path in file_paths:
            try:
                result = self._process_single_file(file_path)
                results.append(result)
                
            except ParseError as e:
                self._handle_parse_error(e, file_path)
                
            except Exception as e:
                self._handle_unexpected_error(e, file_path)
        
        return ProcessResult(
            successful=results,
            failed=self.errors,
            total=len(file_paths)
        )
    
    def _handle_parse_error(self, error: ParseError, file_path: str):
        error_entry = ErrorEntry(
            file_path=file_path,
            error=error,
            recoverable=True
        )
        
        if self.error_strategy == "fail_fast":
            raise error
        elif self.error_strategy == "continue":
            logger.warning(f"Skipping file {file_path}: {error}")
            self.errors.append(error_entry)
        else:  # collect
            self.errors.append(error_entry)
```

### 4.2 Neo4jæ¥ç¶šã®å†è©¦è¡Œæˆ¦ç•¥

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class Neo4jConnector:
    def __init__(self, config: dict):
        self.config = config
        self.max_retries = config.get("max_retries", 3)
        self.retry_delay = config.get("retry_delay", 1.0)
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        retry=retry_if_exception_type((ServiceUnavailable, SessionExpired))
    )
    def connect(self) -> Driver:
        try:
            driver = GraphDatabase.driver(
                self.config["uri"],
                auth=(self.config["username"], self.config["password"])
            )
            # æ¥ç¶šãƒ†ã‚¹ãƒˆ
            driver.verify_connectivity()
            return driver
            
        except AuthError as e:
            # èªè¨¼ã‚¨ãƒ©ãƒ¼ã¯å†è©¦è¡Œã—ãªã„
            raise Neo4jConnectionError(
                "Authentication failed",
                error_code=ErrorCode.AUTHENTICATION_FAILED,
                details={"uri": self.config["uri"], "username": self.config["username"]}
            ) from e
            
        except ServiceUnavailable as e:
            # ã‚µãƒ¼ãƒ“ã‚¹åˆ©ç”¨ä¸å¯ã¯å†è©¦è¡Œå¯¾è±¡
            logger.warning(f"Neo4j service unavailable, retrying...")
            raise
```

### 4.3 ãƒãƒƒãƒå‡¦ç†ã§ã®éƒ¨åˆ†çš„å¤±æ•—

```python
class BatchProcessor:
    def __init__(self, neo4j_driver, batch_size: int = 1000):
        self.driver = neo4j_driver
        self.batch_size = batch_size
    
    def process_batch(self, nodes: List[ASTGraphNode]) -> BatchResult:
        successful = []
        failed = []
        
        # ãƒãƒƒãƒã‚’å°ã•ãªãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²
        for chunk in self._chunk_nodes(nodes, self.batch_size):
            try:
                self._write_chunk(chunk)
                successful.extend(chunk)
                
            except Neo4jError as e:
                # ãƒãƒ£ãƒ³ã‚¯å¤±æ•—æ™‚ã€å€‹åˆ¥å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                chunk_failed = self._process_chunk_individually(chunk)
                failed.extend(chunk_failed)
                successful.extend(c for c in chunk if c not in chunk_failed)
        
        return BatchResult(
            successful_count=len(successful),
            failed_count=len(failed),
            failed_nodes=failed,
            partial_success=len(failed) > 0 and len(successful) > 0
        )
    
    def _process_chunk_individually(self, chunk: List[ASTGraphNode]) -> List[ASTGraphNode]:
        """ãƒãƒ£ãƒ³ã‚¯å†…ã®å„ãƒãƒ¼ãƒ‰ã‚’å€‹åˆ¥ã«å‡¦ç†"""
        failed = []
        
        for node in chunk:
            try:
                self._write_single_node(node)
            except Exception as e:
                logger.error(f"Failed to write node {node.id}: {e}")
                failed.append(node)
        
        return failed
```

## 5. ã‚¨ãƒ©ãƒ¼å›å¾©ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 

### 5.1 è‡ªå‹•å›å¾©æˆ¦ç•¥

```python
class ErrorRecovery:
    @staticmethod
    def with_fallback(primary_func, fallback_func, *args, **kwargs):
        """ãƒ—ãƒ©ã‚¤ãƒãƒªé–¢æ•°å¤±æ•—æ™‚ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ"""
        try:
            return primary_func(*args, **kwargs)
        except Exception as e:
            logger.warning(f"Primary function failed: {e}, trying fallback")
            return fallback_func(*args, **kwargs)
    
    @staticmethod
    def with_circuit_breaker(func, failure_threshold=5, timeout=60):
        """é€£ç¶šå¤±æ•—æ™‚ã«ä¸€æ™‚çš„ã«å‡¦ç†ã‚’åœæ­¢"""
        failures = 0
        last_failure_time = None
        
        def wrapper(*args, **kwargs):
            nonlocal failures, last_failure_time
            
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾Œã¯ãƒªã‚»ãƒƒãƒˆ
            if last_failure_time and (time.time() - last_failure_time) > timeout:
                failures = 0
            
            if failures >= failure_threshold:
                raise CircuitBreakerOpen(
                    f"Circuit breaker open after {failures} failures"
                )
            
            try:
                result = func(*args, **kwargs)
                failures = 0  # æˆåŠŸã—ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                return result
            except Exception as e:
                failures += 1
                last_failure_time = time.time()
                raise
        
        return wrapper
```

### 5.2 ã‚¨ãƒ©ãƒ¼æ™‚ã®çŠ¶æ…‹ä¿å­˜

```python
class StateRecovery:
    def __init__(self, checkpoint_dir: Path):
        self.checkpoint_dir = checkpoint_dir
        self.checkpoint_dir.mkdir(exist_ok=True)
    
    def save_checkpoint(self, state: ProcessingState):
        """å‡¦ç†çŠ¶æ…‹ã‚’ä¿å­˜"""
        checkpoint_file = self.checkpoint_dir / f"checkpoint_{state.timestamp}.json"
        
        with open(checkpoint_file, 'w') as f:
            json.dump({
                "processed_files": state.processed_files,
                "failed_files": state.failed_files,
                "last_successful_file": state.last_successful_file,
                "timestamp": state.timestamp.isoformat()
            }, f)
    
    def resume_from_checkpoint(self) -> Optional[ProcessingState]:
        """æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰å†é–‹"""
        checkpoints = sorted(self.checkpoint_dir.glob("checkpoint_*.json"))
        
        if not checkpoints:
            return None
        
        latest = checkpoints[-1]
        with open(latest) as f:
            data = json.load(f)
            
        return ProcessingState(
            processed_files=set(data["processed_files"]),
            failed_files=data["failed_files"],
            last_successful_file=data["last_successful_file"],
            timestamp=datetime.fromisoformat(data["timestamp"])
        )
```

## 6. ã‚¨ãƒ©ãƒ¼å ±å‘Šã¨ãƒ­ã‚°

### 6.1 æ§‹é€ åŒ–ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒãƒ¼ãƒˆ

```python
@dataclass
class ErrorReport:
    summary: str
    total_errors: int
    errors_by_type: Dict[str, int]
    errors_by_file: Dict[str, List[Exception]]
    recommendations: List[str]
    
    def to_json(self) -> str:
        return json.dumps({
            "summary": self.summary,
            "total_errors": self.total_errors,
            "errors_by_type": self.errors_by_type,
            "errors_by_file": {
                file: [str(e) for e in errors]
                for file, errors in self.errors_by_file.items()
            },
            "recommendations": self.recommendations,
            "timestamp": datetime.utcnow().isoformat()
        }, indent=2)
    
    def to_markdown(self) -> str:
        md = f"# Error Report\n\n"
        md += f"**Summary**: {self.summary}\n"
        md += f"**Total Errors**: {self.total_errors}\n\n"
        
        md += "## Errors by Type\n"
        for error_type, count in self.errors_by_type.items():
            md += f"- {error_type}: {count}\n"
        
        md += "\n## Recommendations\n"
        for rec in self.recommendations:
            md += f"- {rec}\n"
        
        return md
```

### 6.2 ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä»˜ããƒ­ã‚°

```python
class ContextualLogger:
    def __init__(self, logger):
        self.logger = logger
        self.context = {}
    
    def set_context(self, **kwargs):
        self.context.update(kwargs)
    
    def log_error(self, error: Exception, **extra_context):
        context = {**self.context, **extra_context}
        
        self.logger.error(
            f"{error.__class__.__name__}: {str(error)}",
            extra={
                "error_type": error.__class__.__name__,
                "error_code": getattr(error, "error_code", None),
                "file_path": context.get("file_path"),
                "line_number": getattr(error, "lineno", None),
                "traceback": traceback.format_exc(),
                **context
            }
        )
```

## 7. ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

### 7.1 ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

```python
ERROR_MESSAGES = {
    ErrorCode.SYNTAX_ERROR: {
        "message": "Python syntax error in file '{file_path}' at line {line_number}",
        "suggestion": "Check the Python syntax. Run 'python -m py_compile {file_path}' to validate.",
        "severity": "warning"
    },
    ErrorCode.CONNECTION_FAILED: {
        "message": "Failed to connect to Neo4j at {uri}",
        "suggestion": "Ensure Neo4j is running and accessible. Check firewall settings for port 7687.",
        "severity": "critical"
    },
    ErrorCode.AUTHENTICATION_FAILED: {
        "message": "Neo4j authentication failed for user '{username}'",
        "suggestion": "Verify NEO4J_PASSWORD environment variable is set correctly.",
        "severity": "critical"
    }
}

def format_user_error(error_code: str, **context) -> str:
    template = ERROR_MESSAGES.get(error_code, {})
    message = template.get("message", "Unknown error").format(**context)
    suggestion = template.get("suggestion", "")
    
    return f"{message}\nğŸ’¡ {suggestion}" if suggestion else message
```

## 8. ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®è¨­å®š

### 8.1 ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š

```python
class ErrorHandlingConfig:
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    DEFAULT = {
        "file_error_strategy": "continue",  # continue, fail_fast, collect
        "max_retries": 3,
        "retry_delay": 1.0,
        "enable_checkpoints": True,
        "checkpoint_interval": 100,  # ãƒ•ã‚¡ã‚¤ãƒ«æ•°
        "detailed_errors": False,  # æœ¬ç•ªç’°å¢ƒã§ã¯Falseæ¨å¥¨
    }
    
    @classmethod
    def from_env(cls):
        """ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        return {
            "file_error_strategy": os.getenv("AST2GRAPH_ERROR_STRATEGY", "continue"),
            "max_retries": int(os.getenv("AST2GRAPH_MAX_RETRIES", "3")),
            "detailed_errors": os.getenv("AST2GRAPH_DETAILED_ERRORS", "false").lower() == "true",
        }
```

## 9. ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 9.1 DO
- âœ… å…·ä½“çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨å¯¾å‡¦æ³•ã‚’æä¾›
- âœ… ã‚¨ãƒ©ãƒ¼ã‚’é©åˆ‡ã«åˆ†é¡ã—ã¦å‡¦ç†
- âœ… éƒ¨åˆ†çš„æˆåŠŸã‚’è¨±å®¹ã™ã‚‹è¨­è¨ˆ
- âœ… ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’æ§‹é€ åŒ–ã—ã¦ä¿å­˜
- âœ… å†å®Ÿè¡Œå¯èƒ½ãªè¨­è¨ˆ

### 9.2 DON'T
- âŒ ä¸€èˆ¬çš„ã™ãã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- âŒ ã‚¨ãƒ©ãƒ¼ã‚’æ¡ã‚Šã¤ã¶ã—ã¦ç„¡è¦–
- âŒ ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ãã®ã¾ã¾ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤º
- âŒ ãƒªãƒˆãƒ©ã‚¤ãªã—ã§å³åº§ã«å¤±æ•—
- âŒ ã‚¨ãƒ©ãƒ¼æ™‚ã®çŠ¶æ…‹ã‚’ä¿å­˜ã—ãªã„

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€ast2graphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯å …ç‰¢ã§ä½¿ã„ã‚„ã™ã„ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚