# ast2graphプロジェクト コード品質改善計画

## 作成日時
2025年7月3日 03:56

## 概要
ast2graphプロジェクトのコード品質分析を実施した結果、いくつかの改善点が発見されました。本文書では、発見された問題点と具体的な改善提案をまとめます。

## 現状分析

### 良い点
- 全体的に良好な構造化
- 型ヒントの適切な使用
- カスタム例外クラスの階層的設計
- 高いテストカバレッジ（118テスト全て合格）

### 問題点

## 1. 言語の混在問題

### 問題
- graph_exporter.pyで日本語と英語のドキュメントストリングが混在
- プロジェクト全体での言語統一性の欠如

### 改善提案
```python
# 修正前（graph_exporter.py）
"""グラフ構造をエクスポートする機能を提供"""

# 修正後
"""Provides functionality to export graph structures"""
```

## 2. エラーハンドリングの改善

### 問題点1: StopIterationのリスク
**ファイル**: graph_builder.py（229, 238行目）
```python
# 現状の問題のあるコード
parent_ast = next((k for k, v in self._node_mapping.items() if v == parent_id), None)
```

### 改善提案
```python
def _get_ast_for_node_id(self, node_id: str) -> Optional[ast.AST]:
    """安全にノードIDに対応するASTノードを取得"""
    for ast_node, mapped_id in self._node_mapping.items():
        if mapped_id == node_id:
            return ast_node
    return None
```

### 問題点2: エンコーディング検出のエラー処理
**ファイル**: parser.py（134行目）

### 改善提案
```python
def _detect_encoding(self, file_path: Path) -> str:
    """ファイルのエンコーディングを検出"""
    try:
        with open(file_path, 'rb') as f:
            first_line = f.readline()
            second_line = f.readline()
            
        for line in [first_line, second_line]:
            if match := self._ENCODING_PATTERN.search(line):
                encoding = match.group(1).decode('ascii')
                # エンコーディング名の妥当性チェック
                try:
                    codecs.lookup(encoding)
                    return encoding
                except LookupError:
                    # 無効なエンコーディング名の場合はデフォルトに戻る
                    pass
                    
        return 'utf-8'
    except Exception:
        return 'utf-8'
```

## 3. 高複雑度関数のリファクタリング

### 問題: _determine_edge_typeメソッドの複雑度
**ファイル**: graph_builder.py（202-255行目）

### 改善提案: 戦略パターンの適用
```python
class EdgeTypeStrategy:
    """エッジタイプ決定戦略の基底クラス"""
    
    @abstractmethod
    def can_handle(self, parent: ast.AST, child: ast.AST) -> bool:
        pass
    
    @abstractmethod
    def get_edge_type(self, parent: ast.AST, child: ast.AST) -> EdgeType:
        pass

class FunctionDefStrategy(EdgeTypeStrategy):
    """関数定義のエッジタイプ戦略"""
    
    def can_handle(self, parent: ast.AST, child: ast.AST) -> bool:
        return isinstance(parent, ast.FunctionDef)
    
    def get_edge_type(self, parent: ast.AST, child: ast.AST) -> EdgeType:
        if isinstance(child, ast.arguments):
            return EdgeType.CHILD
        elif child in parent.body:
            return EdgeType.NEXT
        return EdgeType.CHILD

# 使用例
class GraphBuilder:
    def __init__(self):
        self._edge_strategies = [
            FunctionDefStrategy(),
            ClassDefStrategy(),
            # ... 他の戦略
        ]
    
    def _determine_edge_type(self, parent: ast.AST, child: ast.AST) -> EdgeType:
        for strategy in self._edge_strategies:
            if strategy.can_handle(parent, child):
                return strategy.get_edge_type(parent, child)
        return EdgeType.CHILD  # デフォルト
```

## 4. パフォーマンス最適化

### 問題: 大規模グラフでの循環参照検出
**ファイル**: graph_structure.py（177行目）

### 改善提案: 反復的実装
```python
def has_cycle(self) -> bool:
    """グラフに循環があるかチェック（反復的実装）"""
    visited = set()
    rec_stack = set()
    
    def check_cycle_iterative(start_node: str) -> bool:
        stack = [(start_node, 'enter')]
        
        while stack:
            node, action = stack.pop()
            
            if action == 'enter':
                if node in rec_stack:
                    return True
                if node in visited:
                    continue
                    
                visited.add(node)
                rec_stack.add(node)
                stack.append((node, 'exit'))
                
                # 子ノードを逆順で追加（DFSの順序を保つため）
                for edge in reversed(self.get_edges_from(node)):
                    stack.append((edge.target_id, 'enter'))
                    
            else:  # action == 'exit'
                rec_stack.remove(node)
                
        return False
    
    # 全ての未訪問ノードから開始
    for node_id in self._nodes:
        if node_id not in visited:
            if check_cycle_iterative(node_id):
                return True
    
    return False
```

## 5. セキュリティ強化

### 問題: globパターンの検証不足
**ファイル**: api.py（192行目）

### 改善提案
```python
def _validate_glob_pattern(pattern: str) -> str:
    """globパターンの安全性を検証"""
    # 危険なパターンのチェック
    dangerous_patterns = ['..', '~', '$', '`']
    for dangerous in dangerous_patterns:
        if dangerous in pattern:
            raise ValueError(f"Potentially dangerous pattern: {pattern}")
    
    # パターンを正規化
    pattern = os.path.normpath(pattern)
    
    # 絶対パスの禁止
    if os.path.isabs(pattern):
        raise ValueError("Absolute paths are not allowed in glob patterns")
    
    return pattern
```

## 実装優先順位

1. **高優先度**（即座に対応すべき）
   - エラーハンドリングの改善（StopIterationリスク）
   - セキュリティ強化（globパターンの検証）

2. **中優先度**（次のリリースまでに対応）
   - 言語の統一（英語に統一）
   - 高複雑度関数のリファクタリング

3. **低優先度**（長期的な改善）
   - パフォーマンス最適化
   - 追加テストの実装

## 次のステップ

1. 高優先度の問題から順次修正を実施
2. 各修正に対してユニットテストを追加
3. コードレビューの実施
4. ドキュメントの更新

## 期待される効果

- バグの削減による安定性向上
- コードの可読性・保守性の向上
- セキュリティリスクの軽減
- パフォーマンスの改善
- 開発効率の向上

## 備考

- 既存のテストは全て合格しているため、機能面での大きな問題はない
- リファクタリングは段階的に実施し、各段階でテストを確認する
- パフォーマンステストの追加を検討する